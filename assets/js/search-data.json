{
  
    
        "post0": {
            "title": "Github Actions are Awesome!",
            "content": "Github Actions are a way to automate your workflow so you can build continuous-integration/continuous development (CI/CD) workflows. You can run tests, check your library or package can build, generate and commit new files all on various triggers such as pushes, pull requests or even schedules. It&#39;s really awesome for automating lots of different tasks and with scripts the possibilities are endless. It&#39;s even how this website gets built. . Fastpages . This website is built with the amazing fastpages, which alongside nbdev is great for a gentle introduction to Github Actions. . Fastpages allows me to write this post in a Jupyter notebook, and then when I push these notebooks to the blog repository an action takes place that converts them to markdown files and builds the Jekyll site that you are looking at now. . I think this is really neat but I thought it would also be cool to use this workflow to generate an ever-changing header for the front page that is based on the blog posts that have been published recently. . . An action workflow . Fastpages comes with a CI YAML file that looks something like this. I will break this down bit by bit to explain and then show how I modified it so that a new header is generated both when pushing new notebooks and on a schedule: . name: CI on: push: branches: - master # need to filter here so we only deploy when there is a push to master # no filters on pull requests, so intentionally left blank pull_request: workflow_dispatch: jobs: build-site: if: ( github.event.commits[0].message != &#39;Initial commit&#39; ) || github.run_number &gt; 1 runs-on: ubuntu-latest steps: - name: Check if secret exists if: github.event_name == &#39;push&#39; run: | if [ -z &quot;$deploy_key&quot; ] then echo &quot;You do not have a secret named SSH_DEPLOY_KEY. This means you did not follow the setup instructions carefully. Please try setting up your repo again with the right secrets.&quot; exit 1; fi env: deploy_key: $ - name: Copy Repository Contents uses: actions/checkout@main with: persist-credentials: false - name: convert notebooks and word docs to posts uses: ./_action_files - name: setup directories for Jekyll build run: | rm -rf _site sudo chmod -R 777 . - name: Jekyll build uses: docker://fastai/fastpages-jekyll with: args: bash -c &quot;jekyll build -V --strict_front_matter --trace&quot; env: JEKYLL_ENV: &#39;production&#39; - name: copy CNAME file into _site if CNAME exists run: | sudo chmod -R 777 _site/ cp CNAME _site/ 2&gt;/dev/null || : - name: Deploy if: github.event_name == &#39;push&#39; uses: peaceiris/actions-gh-pages@v3 with: deploy_key: $ publish_dir: ./_site . The first bit sets up when the Action file gets run. The following gives the Action a name and specifies it should run on a push to master branch, or pull requests. The workflow_dispatch: allows manual triggering of the workflow from the actions tab or REST API on Github. . name: CI on: push: branches: - master # need to filter here so we only deploy when there is a push to master # no filters on pull requests, so intentionally left blank pull_request: workflow_dispatch: . Next, we set up the job and what it runs on - here it is the latest ubuntu image. What this means is that each time this runs we get a self-contained environment in which to carry out the steps of the workflow. You can see below that we can sprinkle our action files with conditional if: ... statements allowing control flow in our actions. . jobs: build-site: if: ( github.event.commits[0].message != &#39;Initial commit&#39; ) || github.run_number &gt; 1 runs-on: ubuntu-latest . Now it&#39;s time to define the actual steps that we want to execute. The key part here is that we give the step a name and then either have a run: or uses: key for the given step. If we have a run: key we can execute statements as if we were in the bash terminal (this being a ubuntu image) such as cd .. or ls etc. . The use: allows us to use specific actions created by others - of which there are many on the GitHub Actions marketplace. You can pass arguments by using the with: key to these prespecified actions. . The first step below just checks to see if we have set up a deploy key, something which should be done when we first set up a blog with fastpages: . - name: Check if secret exists if: github.event_name == &#39;push&#39; run: | if [ -z &quot;$deploy_key&quot; ] then echo &quot;You do not have a secret named SSH_DEPLOY_KEY. This means you did not follow the setup instructions carefully. Please try setting up your repo again with the right secrets.&quot; exit 1; fi env: deploy_key: $ . Next, it uses a marketplace action to checkout our blog repository and then uses a local action directory to convert our notebooks to markdown files. This conversion puts the markdown in the _posts/ directory of the blog repository. . - name: Copy Repository Contents uses: actions/checkout@main with: persist-credentials: false - name: convert notebooks and word docs to posts uses: ./_action_files . The final few steps build and deploy the Jekyll blog. First, the _site/ directory is cleared and then rebuilt using a Docker container image. The CNAME step is only pertinent if you have a custom domain name, which this blog doesn&#39;t so can be ignored. . Finally the last action peaceiris/actions-gh-pages@v3 takes the fresh _site/ and deploys this to a Github Page, which allows hosting of static sites. Easy right? . - name: setup directories for Jekyll build run: | rm -rf _site sudo chmod -R 777 . - name: Jekyll build uses: docker://fastai/fastpages-jekyll with: args: bash -c &quot;jekyll build -V --strict_front_matter --trace&quot; env: JEKYLL_ENV: &#39;production&#39; - name: copy CNAME file into _site if CNAME exists run: | sudo chmod -R 777 _site/ cp CNAME _site/ 2&gt;/dev/null || : - name: Deploy if: github.event_name == &#39;push&#39; uses: peaceiris/actions-gh-pages@v3 with: deploy_key: $ publish_dir: ./_site . How to make the custom header image . To make the custom header image I wrote a little script of which the main execution function is shown below in the collapsable code fold. It&#39;s not too important to understand it for this explanation, just that it is simple python script that produces a matplotlib plot. The main thing is that it reads the markdown posts in the _posts/ folder to get the titles and dates published, and then it can construct the plot with a list of the titles and time since today&#39;s date expressed in days. . As blog posts only ever get put in the _posts/ directory at site build time and the resulting markdown is not committed to the repository I realised I can slot this script into the current ci.yaml workflow. . def line_plot(post_titles: list, deltas: list, cutoff=-30): &quot;&quot;&quot;Creates the line plot in the XKCD style. Args: post_titles (list): list of post titles deltas (list): list of time since comparison time cutoff (int, optional): cutoff point. Defaults to -30. Returns: tuple : plt.fig, plt.ax &quot;&quot;&quot; with plt.xkcd(): f, ax = plt.subplots(1, 1) x_vals = [i for i in range(cutoff, 0, 1)] y_counts = Counter(deltas) y_vals = [y_counts[x] for x in x_vals] ax.plot(x_vals, y_vals) ax.spines[&#39;top&#39;].set_visible(False) ax.spines[&#39;right&#39;].set_visible(False) ax.set_title(&#39;WELCOME TO THE BLOG!&#39;, fontweight=&#39;bold&#39;, y=1.05) max_y_val = max(y_vals) ax.set_ylim(top=max_y_val+0.3+0.2*len(y_counts)) ax.set_yticks(range(0, max_y_val+1)) ax.set_xlabel(&#39;Days ago...&#39;) ax.set_ylabel(&#39;Number of posts&#39;) arrowprops = dict( arrowstyle=&quot;-&gt;&quot;, connectionstyle=&quot;angle3,angleA=0,angleB=90&quot;) titles_arr = np.array(post_titles) deltas_arr = np.array(deltas) x_offset = 2 y_offset = max_y_val + 0.2*len(y_counts) + 0.2 for x, count in y_counts.items(): post_titles = titles_arr[deltas_arr == x] ax.annotate(&#39; n+ n&#39;.join(post_titles), xy=(x, count), xytext=(x+x_offset, y_offset), arrowprops=arrowprops) y_offset -= 0.2 ax.text(x=1.2, y=0.6, s=&#39;Days since posting...&#39;, transform=ax.transAxes) bbox_props = dict(boxstyle=&quot;round&quot;, fc=&quot;white&quot;, ec=&quot;black&quot;) if len(deltas) &gt; 0: last_post_days = str(abs(deltas[-1]) - 1) else: last_post_days = &#39;+&#39; + str(abs(cutoff)) ax.text(1.3, 0.4, last_post_days, bbox=bbox_props, transform=ax.transAxes, fontsize=24) exclam = &#39;&quot;Nice!&quot;&#39; if int(last_post_days) &lt; 14 else &#39;&quot;UH OH!&quot;&#39; ax.text(1.28, 0.1, exclam, transform=ax.transAxes, rotation=25) f.set_size_inches(12, 2.5) return f, ax . . Here are the changes I made to make that work. . Firstly I had to add another trigger to the action. It&#39;s fine that it runs on push as I want new blog posts to be added to the header as they are published. But I also want it to update every day so that the time since publishing updates daily for each post. Handily, GitHub actions have a schedule trigger where we can set a schedule for the action to occur using Cron expressions. . name: CI on: push: branches: - master # need to filter here so we only deploy when there is a push to master # no filters on pull requests, so intentionally left blank pull_request: workflow_dispatch: schedule: - cron: &quot;0 1 * * *&quot; . This Cron expression means the action will happen every day at 1 am. Check this handy website if you need to write Cron expression https://crontab.guru/. . Next, I slot the script and associated setup in between - name: convert notebooks and word docs to posts and the - name: setup directories for Jekyll build steps. . To use the script we need to have python and the required libraries installed. Luckily this is again quite easy using the actions/setup-python action followed by a run: pip install -r requirements.txt step. These are the - name: setup python and - name: Install dependencies steps, respectively. . The next step installs the humor sans font that is required by plt.xkcd and then finally we run the script in the - name: make-header step. . - name: convert notebooks and word docs to posts uses: ./_action_files - name: setup python uses: actions/setup-python@v2 with: python-version: 3.7 - name: Install dependencies run: | python -m pip install --upgrade pip pip install -r requirements.txt - name: Install humor sans font run: | sudo apt-get update -y sudo apt-get install -y fonts-humor-sans rm -rf ~/.cache/matplotlib - name: make-header run: | python scripts/make_header.py - name: setup directories for Jekyll build run: | rm -rf _site sudo chmod -R 777 . . The very last thing we have to change is the conditional if: in the final - name: Deploy step to also run this when the github.event_name is equal to &#39;schedule&#39;. Viola! . - name: Deploy if: ( github.event_name == &#39;push&#39; ) || ( github.event_name == &#39;schedule&#39; ) uses: peaceiris/actions-gh-pages@v3 with: deploy_key: $ publish_dir: ./_site . Here is the new ci.yaml workflow file in full: . name: CI on: push: branches: - master # need to filter here so we only deploy when there is a push to master # no filters on pull requests, so intentionally left blank pull_request: workflow_dispatch: schedule: - cron: &quot;0 1 * * *&quot; jobs: build-site: if: ( github.event.commits[0].message != &#39;Initial commit&#39; ) || github.run_number &gt; 1 runs-on: ubuntu-latest steps: - name: Check if secret exists if: ( github.event_name == &#39;push&#39; ) || ( github.event_name == &#39;schedule&#39; ) run: | if [ -z &quot;$deploy_key&quot; ] then echo &quot;You do not have a secret named SSH_DEPLOY_KEY. This means you did not follow the setup instructions carefully. Please try setting up your repo again with the right secrets.&quot; exit 1; fi env: deploy_key: $ - name: Copy Repository Contents uses: actions/checkout@main with: persist-credentials: false - name: convert notebooks and word docs to posts uses: ./_action_files - name: setup python uses: actions/setup-python@v2 with: python-version: 3.7 - name: Install dependencies run: | python -m pip install --upgrade pip pip install -r requirements.txt - name: Install humor sans font run: | sudo apt-get update -y sudo apt-get install -y fonts-humor-sans rm -rf ~/.cache/matplotlib - name: make-header run: | python scripts/make_header.py - name: setup directories for Jekyll build run: | rm -rf _site sudo chmod -R 777 . - name: Jekyll build uses: docker://fastai/fastpages-jekyll with: args: bash -c &quot;jekyll build -V --strict_front_matter --trace&quot; env: JEKYLL_ENV: &#39;production&#39; - name: copy CNAME file into _site if CNAME exists run: | sudo chmod -R 777 _site/ cp CNAME _site/ 2&gt;/dev/null || : - name: Deploy if: ( github.event_name == &#39;push&#39; ) || ( github.event_name == &#39;schedule&#39; ) uses: peaceiris/actions-gh-pages@v3 with: deploy_key: $ publish_dir: ./_site .",
            "url": "https://jc639.github.io/blog/github/ci/actions/2021/03/06/github_actions.html",
            "relUrl": "/github/ci/actions/2021/03/06/github_actions.html",
            "date": " • Mar 6, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Hello",
            "content": "Testing 1, 2, 3... Is anyone out there? Hello to anyone reading this and welcome to this blog. I intend to write here semi-regularly covering various topics in the data science space, as well as deep learning. . I am a data scientist at an FTSE 100 company, and do lots of various things covering a wide range of data science techniques but not so much deep learning. . I really enjoy deep learning and as you can see in the past I have done some projects in the past using deep learning techniques, such as: . handwriting recognition | character RNN | album cover genre image recognition | . But I want to do more stuff regularly and plan to use this blog to do that. The writing here will be a consolidation of any learning and is mainly for me, but if anyone else finds it useful that is great! .",
            "url": "https://jc639.github.io/blog/2021/02/27/Hello.html",
            "relUrl": "/2021/02/27/Hello.html",
            "date": " • Feb 27, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "I am a data scientist at a FTSE 100 company. This blog represents my personal opinions and musings on data science. . I decided to start blogging after completing the fastai deep learning course, where they suggest writing can help you solidify your learnings. Two reasons given for starting a blog stood out to me: . “It’s like a resume but better!” | “Helps you learn” | . I am keenly interested in deep learning but don’t get much opportunity to apply the skills I learn at my job unfortunately. I want to use this blog to help with learning but also document those skills that might not be evident from my CV. If someone finds something useful that I have written as part of that, then that’s great! .",
          "url": "https://jc639.github.io/blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://jc639.github.io/blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}